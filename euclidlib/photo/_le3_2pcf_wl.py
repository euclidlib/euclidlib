from __future__ import annotations

from os import PathLike
import numpy as np
import fitsio  # type: ignore [import-not-found]
from numpy.typing import NDArray
from dataclasses import dataclass

TYPE_CHECKING = False
if TYPE_CHECKING:
    from typing import TypeAlias, Any

    _DictKey: TypeAlias = str | int | tuple["_DictKey", ...]


def normalize_result_axis(
    axis: tuple[int, ...] | int | None,
    result: NDArray[Any],
    ell: tuple[NDArray[Any], ...] | NDArray[Any] | None,
) -> tuple[int, ...]:
    """Return an axis tuple for a result."""
    try:
        from numpy.lib.array_utils import normalize_axis_tuple
    except ModuleNotFoundError:
        from numpy.lib.stride_tricks import normalize_axis_tuple  # type: ignore

    if axis is None:
        if result.ndim == 0:
            axis = ()
        elif isinstance(ell, tuple):
            axis = tuple(range(-len(ell), 0))
        else:
            axis = -1
    return normalize_axis_tuple(axis, result.ndim, "axis")


def _key_from_string(s: str) -> tuple[str, str, int, int] | None:
    """return key from string representation"""
    tuple_key_dict = None
    if "POSPOS" in s:
        name_split = s.split("_")
        tuple_key_dict = ("POS", "POS", int(name_split[-2]), int(name_split[-1]))
    elif "POSSHEAR" in s:
        name_split = s.split("_")
        tuple_key_dict = ("POS", "SHE", int(name_split[-2]), int(name_split[-1]))
    elif "SHEAR" in s:
        name_split = s.split("_")
        tuple_key_dict = ("SHE", "SHE", int(name_split[-2]), int(name_split[-1]))
    return tuple_key_dict


@dataclass(frozen=True, repr=False)
class Result:
    """
    Container for results.
    """

    array: NDArray[Any]
    ell: NDArray[Any] | tuple[NDArray[Any], ...] | None = None
    axis: int | tuple[int, ...] | None = None
    lower: NDArray[Any] | tuple[NDArray[Any], ...] | None = None
    upper: NDArray[Any] | tuple[NDArray[Any], ...] | None = None
    weight: NDArray[Any] | tuple[NDArray[Any], ...] | None = None

    def __post_init__(self) -> None:
        # Ensure array is of float dtype
        float_array = np.asarray(self.array, dtype=float)
        object.__setattr__(self, "array", float_array)

        # Normalize the axis after setting the array
        axis = normalize_result_axis(self.axis, self.array, self.ell)
        object.__setattr__(self, "axis", axis)

    def __repr__(self) -> str:
        return f"{self.__class__.__name__}(axis={self.axis!r})"

    def __array__(
        self,
        dtype: np.dtype[Any] | None = None,
        *,
        copy: np.bool[bool] | None = None,
    ) -> NDArray[Any]:
        if copy is not None:
            return self.array.__array__(dtype, copy=copy)
        return self.array.__array__(dtype)

    def __getitem__(self, key: Any) -> Any:
        return self.array[key]

    @property
    def ndim(self) -> int:
        return self.array.ndim

    @property
    def shape(self) -> tuple[int, ...]:
        return self.array.shape

    @property
    def dtype(self) -> np.dtype[Any]:
        return self.array.dtype


def correlation_functions(path: str | PathLike[str]) -> dict[_DictKey, NDArray[Any]]:
    """
    Reads 2D correlation functions from a Euclid data product.

    Parameters
    ----------
    path : str | PathLike[str]
        The path to the FITS file containing the Euclid data product.

    Returns
    -------
    dict[_DictKey, NDArray[Any]]
        A dictionary where each key is a tuple representing the HDU name (generated by
        `_key_from_string`), and each value is a NumPy array containing the data of
        the corresponding HDU.

    Notes
    -----
    - Only HDUs whose extension name contains '2D' are considered.
    - The `fitsio.FITS` context manager is used to read the FITS file efficiently.
    - The function depends on `_key_from_string()` to convert the HDU names into keys
      for the output dictionary.
    """

    xi: dict[_DictKey, NDArray[Any]] = {}
    with fitsio.FITS(path) as fits:
        for hdu in fits[1:]:
            extname = hdu.get_extname()
            key = _key_from_string(extname)
            if key is None:
                continue
            data = hdu.read()
            THETA = data["THETA"]
            bin_size = np.log(THETA[1]) - np.log(THETA[0])
            half_bins = np.exp(0.5 * bin_size)
            LOWER = THETA / half_bins
            UPPER = THETA * half_bins
            WEIGHT = data["WEIGHT"]
            print(path)
            if "2PCF-WL-CS" in str(path):
                array = np.array(
                    [[data["XI_P"], data["XI_X"]], [data["XI_X"], data["XI_M"]]]
                )
                axis = (2,)
            elif "2PCF-WL-GGL" in str(path):
                array = np.array([data["GAMMA_T"], data["GAMMA_X"]])
                axis = (1,)
            elif "2PCF-WL-SA" in str(path):
                array = np.array(data["WTHETA"])
                axis = (0,)
            else:
                print("Unknown file type")

            xi[key] = Result(array, THETA, axis, LOWER, UPPER, WEIGHT)
    return xi


def bandpowers(path: str | PathLike[str]) -> dict[_DictKey, NDArray[Any]]:
    """
    Reads 2D bandpowers from a Euclid data product.

    Parameters
    ----------
    path : str | PathLike[str]
        The path to the FITS file containing the Euclid bandpower data product.

    Returns
    -------
    dict[_DictKey, NDArray[Any]]
        A dictionary where each key is a tuple representing the HDU name (generated by
        `_key_from_string`), and each value is a NumPy array containing the data of
        the corresponding HDU.

    Notes
    -----
    - Only HDUs whose extension name contains '2D' are considered.
    - The `fitsio.FITS` context manager is used to read the FITS file efficiently.
    - The function depends on `_key_from_string()` to convert the HDU names into keys
      for the output dictionary.
    """
    bandp: dict[_DictKey, NDArray[Any]] = {}
    with fitsio.FITS(path) as fits:
        for hdu in fits:
            if "2D" not in hdu.get_extname():
                continue
            key = _key_from_string(hdu.get_extname())
            if key is None:
                continue
            data = hdu.read()
            if key[:2] == ("POS", "POS"):
                data.dtype.names = ["L", "CL", "LMIN", "LMAX"]
            elif key[:2] == ("POS", "SHE"):
                data.dtype.names = ["L", "CL_E", "CL_B", "LMIN", "LMAX"]
            elif key[:2] == ("SHE", "SHE"):
                data.dtype.names = ["L", "CL_E", "CL_B", "LMIN", "LMAX"]
            bandp[key] = data
    return bandp


def cosebis(path: str | PathLike[str]) -> dict[_DictKey, NDArray[Any]]:
    """
    Reads 2D bandpowers from a Euclid data product.

    Parameters
    ----------
    path : str | PathLike[str]
        The path to the FITS file containing the Euclid bandpower data product.

    Returns
    -------
    dict[_DictKey, NDArray[Any]]
        A dictionary where each key is a tuple representing the HDU name (generated by
        `_key_from_string`), and each value is a NumPy array containing the data of
        the corresponding HDU.

    Notes
    -----
    - Only HDUs whose extension name contains '2D' are considered.
    - The `fitsio.FITS` context manager is used to read the FITS file efficiently.
    - The function depends on `_key_from_string()` to convert the HDU names into keys
      for the output dictionary.
    """

    cb: dict[_DictKey, NDArray[Any]] = {}
    with fitsio.FITS(path) as fits:
        for hdu in fits:
            if "2D" not in hdu.get_extname():
                continue
            key = _key_from_string(hdu.get_extname())
            if key is None:
                continue
            cb[key] = hdu.read()
    return cb
